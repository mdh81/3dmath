#pragma once

#include "Primitive.h"
#include "../Vector.h"
#include <tuple>
#include <vector>
#include <filesystem>
#include <fstream>

namespace math3d {
    // Simple convex shapes that have a well-defined center and
    // are represented using triangular faces
    class ConvexPrimitive : public Primitive {

    public:
        using Tri = std::tuple<unsigned, unsigned, unsigned>;
        using Tris = std::vector<Tri>;

    public:
        explicit ConvexPrimitive(Point const& center) // NOLINT
        : center(center) {
        }

        Tri orientTriangleNormalOutside(Tri&& tri) {
            auto correctNormalOrientation = vertices.at(std::get<0>(tri)) - center;
            auto AB = vertices.at(std::get<1>(tri)) - vertices.at(std::get<0>(tri));
            auto AC = vertices.at(std::get<2>(tri)) - vertices.at(std::get<0>(tri));
            auto normal = AB * AC;
            if (correctNormalOrientation.dot(normal) < 0) {
                auto tmp = std::get<2>(tri);
                std::get<2>(tri) = std::get<1>(tri);
                std::get<1>(tri) = tmp;
            }
            return tri;
        }

        [[nodiscard]]
        Point getCenter() const {
            return center;
        }

        [[nodiscard]]
        Tris const& getTris() {
            return tris;
        }

        void writeToSTL(std::filesystem::path const& outputFile) {
            if (vertices.empty()) {
                generateGeometry();
            }

            std::ofstream ofs(outputFile.string());
            if (!ofs) {
                throw std::runtime_error("Unable to open " + outputFile.string() + " for writing");
            }

            auto header = "STL generated by 3dmath";
            ofs.write(header, 80);
            unsigned numTris = tris.size();
            unsigned short dummy = 0;
            ofs.write(reinterpret_cast<char*>(&numTris), sizeof(numTris));
            for (auto& tri : tris) {
                auto& a = vertices.at(get<0>(tri));
                auto& b = vertices.at(get<1>(tri));
                auto& c = vertices.at(get<2>(tri));
                auto ab = b - a;
                auto ac = c - a;
                auto normal = ab * ac;
                ofs.write(reinterpret_cast<char*>(normal.getData()), sizeof(float) * 3);
                ofs.write(reinterpret_cast<char*>(a.getData()), sizeof(float) * 3);
                ofs.write(reinterpret_cast<char*>(b.getData()), sizeof(float) * 3);
                ofs.write(reinterpret_cast<char*>(c.getData()), sizeof(float) * 3);
                ofs.write(reinterpret_cast<char*>(&dummy), sizeof(unsigned short));
            }
            ofs.close();
        }

    protected:
        Point center;
        Tris tris;
    };

}